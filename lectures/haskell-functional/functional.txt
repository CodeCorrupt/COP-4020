Lecture -*- Outline -*-
------------------------------------------

* Closures and Functions (Thompson 9 and 10, Davie 5)

------------------------------------------

* \ makes functions

This is called and 

- lambda in Scheme and Lisp
- fn in SML
- a block in Smalltalk and Ruby

Used for avoiding redundancy in code (functional abstraction)
and for building tools

------------------------------------------

* \ makes functions (closures)

Prelude> (\ x -> x) "y"

Prelude> ((\ x -> head x) [1,2,3])

Prelude> ((\ (x,y) -> 0) (head [], "hmm"))

Prelude> (\ () -> 5)

Prelude> (\ () -> 5)()

Notes:

- the function (\ x -> head x) is the same as head

- the \ extends as far to right as possible
  so best to use parens around it

------------------------------------------

* Curried functions

> cadd = \x -> \y -> x + y
> add2 = (cadd 2)

Prelude> :type cadd
cadd :: Integer -> Integer -> Integer
Prelude> :type add2
add2 :: Integer -> Integer
 
Functions are "automatically" curried in Haskell,
since the definition

  cadd x y = x + y

is equivalent to the one given above

One use of curried functions is as "partial application" as shown by
the function "add2".  This prevents writing 2 redundantly in code...

But the point is we can use cadd to make lots of tools,
add3, add4, add5, etc. all *at run-time*, we don't
have to write a (redundant) separate definition for each.

Show example with curried subtraction.

------------------------------------------

* Closure in C++ and Java

A closure is: environment (values for free vars) + code

What in C++ or Java is like a closure?

An object: it has a little environment (data members)
and code (member functions)

But in C++, don't have anonymous classes,
and can't capture the environment at run-time without
preparing with class definition ahead of time.

------------------------------------------

* Abstracting a common pattern ==> Folding

> sum :: Num a => [a] -> a
> sum [] = 0
> sum (x:xs) = x + sum xs

> product :: Num a => [a] -> a
> product [] = 1
> product (x:xs) = x * product xs

------------------------------------------

* The function foldr1

>foldr1 :: (a -> a -> a) -> [a] -> a

The definition of foldr1 has two cases:

>foldr1 f [x]    = x

>foldr1 f (x:xs) = f x (foldr1 f xs)

The first argument is a binary function
over type a.

For example, the function (+) over Int.

The second argument is a list of elements
of type a that are to be combined using 
the operator.

For instance, [3, 98, 1] 

------------------------------------------

* Examples of foldr1

>foldr1 (+) [3,98,1] == 102
>foldr1 (||) [False,True,False] == True
>foldr1 (++) ["Freak ", "Out", " ", "!"] == "Freak Out!"
>foldr1 min [6] == 6
>foldr1 (*) [1..6] == 720

------------------------------------------

* The function foldr

The function foldr1 gives an error when applied
to an empty list argument.

We can modify the definition to give an extra argument
that is the value returned on the empty list, so 
giving a function defined on all finite lists.

>foldr :: (a  ->  a  ->  a)  ->  a  ->  [a]  ->  a
                  ^              ^       ^       ^
                  |              |       |       |
                binary           |       |       |
                operation        |       |     result
                              starting   |
                              value      |
                                       list of 
                                       values to
 
                                      be combined
>foldr f s [] = s
>foldr f s (x:xs) = f x (foldr f s xs)

Alternative definition using infix notation

> foldr :: (a -> b -> b) -> b -> [a] -> b
> foldr op s []      = s
> foldr op s (x:xs)  = x `op` (foldr op s xs)

------------------------------------------

* Example of functions defined with foldr

We can now define some of the standard functions of Haskell.

concat :: [[a]] -> [a]
concat xs = foldr (++) [] xs

and :: [Bool] -> Bool
and bs = foldr (&&) True bs

------------------------------------------

* foldr1 in terms of fold

foldr1 is designed to take a list with at least
one element.  We can also define foldr1
from foldr, like this

foldr1 f xs = foldr f (last xs) (init xs)

where last gives the last element of a list,
and init removes that element.

------------------------------------------

* Folding in general - foldr again

The most general type of foldr is defined as
follows:

foldr :: (a -> b -> b) -> b -> [a] -> b

------------------------------------------

* Examples of functions defined with foldr

reverse a list

rev :: [a] -> a
rev xs = foldr snoc [] xs

snoc :: a -> [a] -> [a]
snoc x xs = xs ++ [x]

iSort :: [Integer] -> [Integer]
iSort xs = foldr ins [] xs

------------------------------------------

* For you to do

Implement the function ins that is used
in iSort (insertion sort).  What is its type?
  
>iSort :: [Integer] -> [Integer]
>iSort xs = foldr ins [] xs

see ISort.hs

------------------------------------------

* Abstraction on a different data type

------------------------------------------

* Generalized fold

> data Tree a =   Lf
>               | Br (a, Tree a, Tree a)
>                   deriving (Eq, Show)

Generalize:

> preorder :: Tree a -> [a]
> preorder Lf = []
> preorder (Br(v,t1,t2)) =
>    [v] ++ preorder t1 ++ preorder t2

> inc :: Num a => Tree a -> Tree a
> inc Lf = Lf
> inc (Br(v,t1,t2)) =
>    Br(v + fromInteger 1, inc t1, inc t2)

see TreeFold.hs

------------------------------------------
