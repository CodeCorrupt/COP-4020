Lecture -*- Outline -*-

* Types in Haskell (Ch 13 in Thompson, Ch 4 in Davie)

Static type systems can catch program errors
before the program is run.

------------------------------------------
    
* Terminology: static vs. dynamic type checking

def: a *static* property is one that
     can be checked before runtime

def: a *dynamic* property must be checked
     (in general) at runtime

def: a *type error* is a successful use 
     a function outside of its domain

def: a program is *type safe* if it cannot
     have a type error at runtime

------------------------------------------
     
* Static and dynamic type checking in different languages

Q: When is static type safety checked?

   before runtime

Q: What languages have static type checking?

   Haskell, Java, C++

Q: What languages have dynamic type checking?

   Smalltalk, Ruby, Python, Erlang, ...

------------------------------------------

* Type operators (Davie 4.1)
    
Haskell's type system has several interesting features...

------------------------------------------

* Type notation

Type declarations

	x :: Integer
	f :: Integer -> Integer

Type operators

  operator	meaning
  =============================
  _ -> _        function type
  (_ , _)       product type
  [ _ ]         list type

Note that the function type is right associative:

  s -> t -> u  means  s -> (t -> u)

  s->t->u->v   means  s->(t->(u->v))

------------------------------------------

* Polymorphic types (Thompson 9.2, Davie 4.2)

Monomorphic examples:

  Integer
  [Bool] -> Bool
  [(Integer, Integer) -> Bool]

Polymorphic examples:

  [i]
  [b] -> b
  [(i,i) -> Bool]

Can use any variable id for a type name (lower case: a, b, ..., z)

------------------------------------------

* Type synonyms (Davie 4.3.1)

Examples

> type Nat = Int
> type TextString = [(Nat, String)]

> type Stack a = [a]
> type Queue a = [a]
> type MyQueue a = Queue a
> type Predicate a = (a -> Bool)

The semantics is that these are just abbreviations.

Q: Do these declaratiosn allow us to pass a (Stack Int)
   to a function of type [Int] -> Int?

------------------------------------------

* Algebraic data types (Thompson 14, Davie 4.4) 

Can simulate enumerations

  data Font = Roman | Italic | Bold

  data Color = Red | Blue | Yellow 

  data Boolean = True | False 

Can also be used to define recursive types

  data Tree a = Lf
              | Br (a, Tree a, Tree a)
                  deriving (Eq, Show)

Recall that the constructor names must start with upper case letter!

------------------------------------------

* Abstract data types (Thompson 15, Davie 4.5, 4.9)

See file Fraction.hs

module Fraction (Fraction, mkFraction,
                 num, denom, add, sub)
where

data Fraction = Integer :/ Integer

mkFraction _ 0 = error "undefined"
mkFraction n d = n :/ d

num (n :/ d)   = n
denom (n :/ d) = d

add (n1 :/ d1) (n2 :/ d2) =
     mkFraction (n1 * d2 + n2 * d1)
                (d1 * d2)
sub (n1 :/ d1) (n2 :/ d2) =
     mkFraction (n1 * d2 - n2 * d1)
                (d1 * d2)

If we had written

module Fraction (Fraction(:/), ...)

then the constructor :/ would have been exported.

Note: To show that :/ is hidden from clients, 
      you have to work from a client module,
      like FractionTests, not from the Fraction module itself.

------------------------------------------

* Free and not free data types

def: a data type is *free* (*algebraic)
     if any value manufactured using the constructor functions is legal
     (according to your idea of what the type should be)

     e.g. Stack, [a], ...

def: a data type is *not free* (abstract)
    if some values manufactured using the constructor functions
    are not legal
	
    e.g. Fraction, Set, PrimeNumber

    Sometimes you have a choice of how to define the type.

    e.g., NonEmptyList

------------------------------------------

* Overview of type inference (Thompson 13, Davie 4.7)

Type checking: you declare type,
	       compiler infers type,
	       compiler compares

Type inference: compiler infers type
                compiler checks consistency

In Haskell don't need to declare types
	(usually)

Example:

> mymap f [] = []
> mymap f (x:xs) = (f x):(mymap f xs)

The compiler infers mymap :: (a->b) -> [a] -> [b]

Since the variables are unconstrained, this is polymorphic

------------------------------------------

* Ad hoc polymorphism and type classes (Thompson 12, Davie 4.8)

Parametric polymorphism:

> map :: (a -> b) -> [a] -> [b]

Ad hoc polymorphism:

> square :: Num a => a -> a
> square x = x * x

The point is that square x only works on those x for which * is defined.

It's illuminating to make a parametric version of this:

squareP :: (a -> a -> a) -> a -> a
squareP mult x = x `mult` x 
		
So what square needs to be polymorphic, is an additional "capability",
the appropriate multiplication routine.

The general idea is that we group types with related sets of
operations into type classes.

In the above example, (Num a =>) gives the name of the type class 
required.

------------------------------------------

* Type classes (Thompson 13.2 and 13.4)

-- abbreviated Eq type class

class Eq a where
  (==), (/=) :: a -> a -> Bool
  x /= y      = not (x==y)

-- abbreviated Ord type class

class (Eq a) => Ord a where
  compare       :: a -> a -> Ordering
  (<), (<=), (>=), (>) :: a -> a -> Bool
  max, min             :: a -> a -> a

There is a "default method" provided for /=, and the ordering stuff
This is similar to an "abstract class" in OOP,
but remember it's *static* overloading

  data Ordering = LT | EQ | GT
                    deriving (Bounded, Enum, Eq, Ord, Read, Show)

The Ord type class is a *subclass* of Eq, it inherits defs from Eq,
really if you think of these as requirements,
it's a refinement (stronger requirement) on clients.

There are also various ways to declare that a type you make up
is an instance of a type class.

------------------------------------------

* Type class instances (Thompson 13.3)

declaring type class instances

> data Prod a b = a :* b

> instance (Eq a, Eq b) => Eq (Prod a b) where
>    (x :* y) == (x' :* y') =
>      (x == x' && y == y')
>
>instance (Show a, Show b) => Show (Prod a b) where
>  show (x :* y) = (show x) ++ " x " ++ (show y)

See TypeClassInstance.hs

Pitfall: apparently the "where" can't be at the same indentation level
         as "instance" for the layout rules to work properly

------------------------------------------

* Higher-order type classes

-- from the Prelude

>class Functor f where
>    fmap :: (a -> b) -> (f a -> f b)

>instance Functor [] where
>    fmap g []     = []
>    fmap g (x:xs) = g x : fmap g xs

Thus fmap has the type (a -> b) -> ([a] -> [b])

>data Maybe a = Nothing | Just a
>            deriving (Eq, Ord, Read, Show)

>instance Functor Maybe where
>    fmap g Nothing  = Nothing
>    fmap g (Just x) = Just (g x)


The type Maybe a is often used with functions that would otherwise
have errors.

------------------------------------------

!!! TO DO: Fix this !!!

* Higher-order type classes

Other instances of Functor from the Prelude
                
instance Functor ((->) a) where
fmap f g x = f (g x)

        (in the Prelude this is
             instance Functor ((->) a) where
                 fmap = (.)

         these are equivalent due to the definition of (.))

        How this works in practice:

        Prelude> fmap not not
        not . not :: Bool -> Bool
        Prelude> fmap not not True
        Bool_True :: Bool
        Prelude> fmap (3+) ((-)4) 10
        -3 :: Integer
        
        Note that we have
        
        Prelude> 3 + (4 - 10)
        -3 :: Integer
        
        How does it type check?
        We must have
           fmap :: (c -> d) -> (((->) a) c) -> (((->) a) d)
        or rather (changing to infix)
           fmap :: (c -> d) -> (a -> c) -> (a -> d)
        
        But this is just the type of the composition operator (.); so it type
        checks immediately.

        Another example:

> inc :: (Functor f, Num a) => f a -> f a
> inc xs = fmap (+1) xs

  With this, try the following:

  inc (Just 3)

  inc [3, 4]
